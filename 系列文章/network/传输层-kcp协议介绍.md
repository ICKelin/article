# kcp协议与tcp对比
首先声明，不保证文章内容绝对正确，毕竟这个话题很大，细节也很多。

在现在公司和之前公司都在用一个名为[kcp](https://github.com/skywind3000/kcp)的udp可靠性传输协议，主要用在两个场景：

- 广域网加速
- 行情香港机房和职场机房之间传输

之前写了不少关于可靠性传输以及tcp可靠性保证，tcp拥塞控制等技术的文章，现在想尝试去对比kcp协议和tcp协议的一些差异，同时将来有机会去做一些协议设计方面的工作也有一个参考。

## kcp
```
0               4   5   6       8 (BYTE)
+---------------+---+---+-------+
|     conv      |cmd|frg|  wnd  |
+---------------+---+---+-------+   8
|     ts        |     sn        |
+---------------+---------------+  16
|     una       |     len       |
+---------------+---------------+  24
|                               |
|        DATA (optional)        |
|                               |
+-------------------------------+
```

先看kcp协议本身，从协议看，是不是比tcp的顺畅多了，字段少了，安排也不想tcp那样紧密了，tcp的状态机按位来用。

conv: 会话id，一个kcp会话一个id
cmd: 命令，平时设计协议我们都会设置一个cmd，这里应该类似
frg: 是否分片，跟ip分片类似，把大包拆分成小包
wnd: 窗口大小
ts: 时间戳
sn: 序列号
una: 未确认的序列号
len: 包长

除了una之外，其他字段都很好理解，协议设计成这样从我的角度来看是很舒服了的。

## 对比
这里主要将作者的一些技术特性进行一个补充

**关于RTO设计**

tcp的RTO在出现丢包时，RTO采用翻倍的方式，tcp的RTO翻倍是处于其协议本身考虑，丢包在TCP当中是一件非常严重的事，一旦出现丢包，tcp认为出现了网络拥塞了，为了避免造成更大的拥塞，下一次丢包重传的检测时间希望更长一些，超时时间长一些，但是，作者认为这个方式会影响其传输速度，因为丢了3次包之后，RTO会很大，要很久才超时，也要很久才进行重传，作者把RTO调整速度减下来，即使网络真的拥塞，也照发不误。

**关于重传设计**

作者指出TCP本身的丢包重传会从丢包的数据开始传输，也就是会重传所有已发送但是未被确认的数据包，也就是类似GBN协议的设计，从我目前了解到的情况来看，TCP并没有采用这样的重传机制，TCP也是重传丢失的数据包，但是和GBN不一样的是TCP的接收方有缓存乱序的数据，所以这点我觉得有待考证。

KCP的设计是选择重传，也就是类似SR协议，只重传丢失的数据包。

TCP有快速重传机制，但是TCP是以超时重传为主，快速重传为辅，当发送方连续三次收到相同的ACK时，会重传这个数据包，打个比方，接收方收到了B，回复说发送方要的是A，接收方收到了C，接收方方回复说我现在要的是A，对方会收到D，对方还是回复说我现在要的是A，这时候发送方就给他A。

KCP的快速重传机制的玩法跟TCP有些不一样，KCP也是根据ACK来判断哪个包丢了，但是是根据某个包被跳过了多少次这个策略进行的。

```
发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，
KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，
直接重传2号包，大大改善了丢包时的传输速度。
```

**关于ACK设计**

TCP 的确认机制相对比较简单，采用的是累积确认，表示这个序列号之前的数据我都收到了，下一个序列号传这个。

但是TCP有个延迟ACK的机制，就是说当收到一个包之后，觉得可以再等等，可能还有下一个包到来，这样我就不用发送两个ACK了。但是再等等会造成RTT的增大，而RTO的计算跟RTT有关，RTT大了，RTO也增大。

KCP在这点上并没有做太多的优化，只是做了可配置。

TCP有选择确认机制，但是是以TCP的选项来进行的的，协议头本身并没有太多的针对选择确认的设计，选择确认告诉对方我当前收到的包的情况，发送方根据这个信息有针对性的重传。

KCP在协议自身设计了UACK+ACK机制，ACK包表明收到这个数据包了，UNA字段跟TCP类似，是累积确认机制，表明此编号前所有包都收到了。

**拥塞控制调整**

也就是KCP作者指出的非退让流控部分，作者指出，发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定，丢包退让和慢启动也就是拥塞控制的机制，关于拥塞控制，可以查看[《tcp拥塞控制》](tcp+congssion.md)了解更多，TCP的拥塞控制应该是被吐槽的比较多的地方，当出现丢包时，TCP的一些实现会要求拥塞窗口立马降到1MSS，发送速度立马就降下来了。

KCP丢弃了丢包退让和慢启动两个过程，不把网络拥塞考虑进去了，使劲的发，反正没有像tcp那么广泛应用，这个也是可配置项，你如果想按照类似tcp的处理方式也行，有自己的想法也行。

```
int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)
- nodelay ：是否启用 nodelay模式，0不启用；1启用。
- interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms
- resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）
- nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。
- 普通模式： ikcp_nodelay(kcp, 0, 40, 0, 0);
- 极速模式： ikcp_nodelay(kcp, 1, 10, 2, 1);
```

kcp的极速模式设置可见端倪，在极速模式下，不开启延迟ack，resend设置为kcp的快速重传机制，2次ACK跨越就重传，nc是拥塞控制开关，关闭之后就是没有控制，也就没有慢启动和拥塞发生时窗口急速调整机制，可见tcp的拥塞控制是大家都觉得不太爽的地方。

我觉得KCP在拥塞控制的处理上是其真正实现快速的原因，当然不否认上面的其他一些机制也能降低延迟，减少RTT，从而降低RTO，但是KCP不做拥塞控制处理也就意味不会把速度拉下来，再重新进入慢启动的过程。

以上为个人的一些观点，不一定正确，毕竟tcp这个协议太复杂，功力不够深厚不敢妄谈。但是kcp这个协议的源代码看起来真的很漂亮，即使有的地方看不懂。。。
